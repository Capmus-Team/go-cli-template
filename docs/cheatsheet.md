# Cheatsheet

Quick reference for working with projects generated by this template.

## Daily Commands

```bash
make check              # format + vet + build + test (before every commit)
make build              # compile to bin/
make serve              # preview server at localhost:8080
go run . version        # run without building
go run . listings       # list seed data as JSON
go run . --help         # see all commands
```

## Adding a New Entity (Full Walkthrough)

Say you're adding "Messages" to the marketplace:

```bash
# 1. Migration first (source of truth)
cat > migrations/003_create_messages.sql << 'SQL'
CREATE TABLE IF NOT EXISTS messages (
    id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id   UUID NOT NULL REFERENCES profiles(id),
    listing_id  UUID NOT NULL REFERENCES listings(id),
    body        TEXT NOT NULL,
    created_at  TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX IF NOT EXISTS idx_messages_listing ON messages(listing_id);
SQL

# 2. Domain type (with json + db tags)
touch internal/domain/message.go

# 3. Add to repository interface + in-memory adapter
# Edit internal/repository/interfaces.go
# Edit internal/repository/inmemory.go

# 4. Business logic + tests
touch internal/service/messages.go
touch internal/service/messages_test.go

# 5. CLI command
touch cmd/messages.go

# 6. Optionally add to serve.go HTTP endpoints
# 7. Add seed data
touch testdata/seed/messages.json

# 8. Verify
make check
```

## Domain Type Template

```go
// internal/domain/message.go
package domain

import "time"

// Message maps to the Supabase "messages" table.
// TypeScript: interface Message { id: string; sender_id: string; ... }
type Message struct {
    ID        string    `json:"id"         db:"id"`
    SenderID  string    `json:"sender_id"  db:"sender_id"`
    ListingID string    `json:"listing_id" db:"listing_id"`
    Body      string    `json:"body"       db:"body"`
    CreatedAt time.Time `json:"created_at" db:"created_at"`
}
```

## Repository Interface Addition

```go
// Add to internal/repository/interfaces.go
type MessageStore interface {
    ListByListing(ctx context.Context, listingID string) ([]domain.Message, error)
    Create(ctx context.Context, msg *domain.Message) error
}
```

## In-Memory Adapter Template

```go
// Add to internal/repository/inmemory.go (or create inmemory_messages.go)

func (r *InMemory) ListByListing(_ context.Context, listingID string) ([]domain.Message, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    var result []domain.Message
    for _, m := range r.messages {
        if m.ListingID == listingID {
            result = append(result, m)
        }
    }
    return result, nil
}
```

## Service Template

```go
// internal/service/messages.go
package service

import (
    "context"
    "myapp/internal/domain"
)

type MessageRepository interface {
    ListByListing(ctx context.Context, listingID string) ([]domain.Message, error)
    Create(ctx context.Context, msg *domain.Message) error
}

type MessageService struct {
    repo MessageRepository
}

func NewMessageService(repo MessageRepository) *MessageService {
    return &MessageService{repo: repo}
}
```

## Command Template

```go
// cmd/messages.go
package cmd

import (
    "fmt"
    "myapp/internal/adapters"
    "myapp/internal/config"
    "myapp/internal/repository"
    "myapp/internal/service"
    "github.com/spf13/cobra"
)

var messagesCmd = &cobra.Command{
    Use:   "messages",
    Short: "List messages for a listing",
    RunE: func(cmd *cobra.Command, args []string) error {
        cfg, _ := config.Load()
        repo := repository.NewInMemory()  // swap to Postgres later
        svc := service.NewMessageService(repo)
        listingID, _ := cmd.Flags().GetString("listing")
        msgs, err := svc.ListByListing(cmd.Context(), listingID)
        if err != nil {
            return fmt.Errorf("fetching messages: %w", err)
        }
        return adapters.Render(cfg.Format, msgs)
    },
}

func init() {
    rootCmd.AddCommand(messagesCmd)
    messagesCmd.Flags().StringP("listing", "l", "", "listing ID")
}
```

## Adding an HTTP Endpoint

```go
// Add inside cmd/serve.go RunE function, after existing handlers:

mux.HandleFunc("GET /api/messages", func(w http.ResponseWriter, r *http.Request) {
    listingID := r.URL.Query().Get("listing_id")
    msgs, err := messageSvc.ListByListing(r.Context(), listingID)
    if err != nil {
        http.Error(w, err.Error(), http.StatusInternalServerError)
        return
    }
    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(msgs)
})
```

## Test Template

```go
// internal/service/messages_test.go
package service

import (
    "context"
    "testing"
    "myapp/internal/domain"
)

type mockMessageRepo struct {
    messages []domain.Message
}

func (m *mockMessageRepo) ListByListing(_ context.Context, listingID string) ([]domain.Message, error) {
    var result []domain.Message
    for _, msg := range m.messages {
        if msg.ListingID == listingID {
            result = append(result, msg)
        }
    }
    return result, nil
}

func (m *mockMessageRepo) Create(_ context.Context, msg *domain.Message) error {
    m.messages = append(m.messages, *msg)
    return nil
}

func TestMessageService_ListByListing(t *testing.T) {
    repo := &mockMessageRepo{
        messages: []domain.Message{
            {ID: "1", ListingID: "L1", Body: "Is this still available?"},
            {ID: "2", ListingID: "L2", Body: "Different listing"},
        },
    }
    svc := NewMessageService(repo)

    msgs, err := svc.ListByListing(context.Background(), "L1")
    if err != nil {
        t.Fatalf("unexpected error: %v", err)
    }
    if len(msgs) != 1 {
        t.Errorf("expected 1 message, got %d", len(msgs))
    }
}
```

## Switching to Postgres

When you're ready for a real database (see AGENTS.md §6.5):

```go
// In any cmd/*.go, change:
repo := repository.NewInMemory()
// To:
repo := repository.NewPostgres(cfg.DatabaseURL)
```

Or auto-detect:
```go
var repo repository.ListingStore
if cfg.DatabaseURL != "" {
    repo = repository.NewPostgres(cfg.DatabaseURL)
} else {
    repo = repository.NewInMemory()
}
```

No changes needed in `internal/service/` — that's the whole point.

## Deploying to Supabase

```bash
# 1. Apply migrations (uncomment RLS policies first)
#    Paste each migrations/*.sql into Supabase SQL Editor

# 2. Generate TypeScript from domain types:
#    internal/domain/listing.go → export interface Listing { ... }
#    json tags = field names

# 3. Port services to Next.js:
#    internal/service/listings.go → app/api/listings/route.ts

# 4. Seed data:
#    Import testdata/seed/*.json via Supabase dashboard
```

## Troubleshooting

| Problem | Fix |
|---|---|
| Import cycle | Move shared types to `domain/`. Use interfaces. |
| File too long (500+) | Split into sibling files, same package. |
| Agent created nested folders | Delete them. Max 3 levels. Read AGENTS.md §4.1. |
| Agent put logic in cmd/ | Move to `service/`. Commands are thin wrappers. |
| Need a new package | You probably don't. Use an existing one. |
| Database not connected | That's fine — in-memory adapter works without one. |
